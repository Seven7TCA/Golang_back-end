学习内容：「【实践课】规则引擎设计与实现」
- 认识规则引擎
- 编译原理基本概念
- 设计一个规则引擎
- 规则引擎的实现

课程目标
- 理解规则引擎的组成部分及应用场景
- 理解规则引擎的核心原理 - 编译原理的相关概念
- 设计并实现一个规则引擎 - `YoungEngine`
- 结合之前所学课程，实现一个Web版规则引擎(自行实现)

[手册](https://juejin.cn/post/7193363381804335161/#heading-15)

# 认识规则引擎

**规则引擎的定义**
- 规则引擎是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策

![规则引擎](../assets/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E.png)
- 解决开发人员重复编码的问题
- 业务决策与服务本身解耦，提高服务的可维护性缩短开发路径，提高效率

**组成部分**

![组成](../assets/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E7%BB%84%E6%88%90.png)
- 数据输入：支持接受使用预定义的语义编写的规则作为策略集
- 规则理解：能够按照预先定义的词法语法、优先级、运算符等正确理解业务规则所表达的语义
- 规则执行：根据执行时输入的参数对策略集中的规则进行正确的解释和执行。同时对规则执行过程中的数据类型进行检查，确保执行结果正确

**应用场景**
- 风控对抗：与黑灰产的对抗过程中，策略研发和产品需要能够根据黑灰产特征进行快速识别和对抗。规则引擎作为风控系统的核心，使产研人员能够不断的调整和优化对抗策略，以实现最好的风控识别效果
- 活动策略运营：业务活动的运营需要及时根据用户效果反馈进行运营策略的优化和调整引入规则引擎后，可以将服务代码与业务运营逻辑解耦，提高运营策略的迭代效率。方便新玩法的探索和效果验证
- 数据分析和清洗：在数据分析系统中使用规则引擎可以便捷的实现对数据进行整理、清洗和转换。数据分析师可以根据不同的需求来自定义数据处理的规则，方便快捷的产出所需要的数据

# 编译原理基本概念

![编译原理](../assets/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.png)

**词法分析** Lexical Analysis：把源代码字符串转换为词法单元(Token)的这个过程

![如何识别Token](../assets/%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%ABToken.png)

**语法分析** Syntax Analysis：在词法分析的基础上，识别表达式的语法结构的过程
- 抽象语法树：表达式的语法结构可以用树来表示，其每个节点(子树)是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点

![抽象语法树](../assets/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.png)

**类型检查**
- 类型综合：根据子表达式的类型构造出父表达式的类型。例如，表达式 A+B 的类型是根据 A 和 B 的类型定义的
- 编译时检查 & 运行时检查：类型检查可以发生在表达式的编译阶段，即在构造语法树的阶段；也可以发生在执行时的阶段
    - 编译时:需要提前声明参数的类型，在构建语法树过程中进行类型检查
    - 执行时:可以根据执行时的参数输入的值类型，在执行过程中进行类型检查

# 设计一个规则引擎

**设计目标**：设计一个规则引擎，支持特定的词法、运算符、数据类型和优先级。并且支持基于以上预定义语法的规则表达式的编译和执行

![词法分析的状态机](../assets/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA.png)

语法分析：
```
expr: logOr EOF;
logor: logorl '||' logAnd | logAnd;
logAnd: logAnd '&&' logNot | logNot;
!logNot: '!' logNot | cmp;
cmp: cmp '>' add | cmp '>=' add | cmp '<' add| cmp '<=' add | cmp '==' add | cmp '!=' add | add;
add: add '+' mul | add '-' mul | mul;
mul: mul '*' pri | mul '/' pri | mul '%' pri | pri;
pri: BooleanLiteral | IntegerLiteral | FloatLiteral | StringLiteral | Identifier | '('expr')';
```
优先级的表达:
```
type precedence struct {
    validSymbols []Symbol // 当前优先级支持的运算符类型
    nextPrecedence *precedence   //更高优先级的
    planner planner // 当前优先级的处理函数
}
```
语法树结构：
- 一元运算符: 左子树为空，右子树为右操作数
- 二元运算符: 左子树为左操作数，右子树为右操作数
- 括号: 左子树为空，右子树为内部表达式的 AST

语法树执行与类型检查：
- 语法树执行：预先定义好每种操作符的执行逻辑，对抽象语法树进行后续遍历执行，即:
    - 先执行左子树，得到左节点的值
    - 再执行右子树，得到有节点的值
    - 最后根据根节点的操作符执行得到根节点的值
- 类型检查
    - 检查时机:执行时检查
    - 检查方法: 在一个节点的左右子节点执行完成后，分别校验左右子节点的类型是否符合对应操作符的类型检查预设规则。
        - '>' 符号要求左右子节点的值都存在且为 int 或 float.
        - '!' 符号要求左节点为空且右节点的值为 bool

# 实现规则引擎

[YoungEngine项目地址](https://github.com/qimengxingyuan/young_engine)
- [需要安装docker环境](https://www.runoob.com/docker/windows-docker-install.html)
- [安装docker-compose工具](https://www.runoob.com/docker/docker-compose.html)

**YoungEngine**

本项目实现了一个简单的规则引擎。 
- 引擎自定义了一套词法、语法。
- 在自定义词法语法的基础上实现了一个典型的编译器前端，能够生成表达式对应的抽象语法树。
- 基于编译构建的抽象语法树实现了 go 版本的虚拟机。通过注入参数可以获得执行结果。

## 词法
引擎支持指定的运算符和数据类型

**运算符**
- 一元计算符 : `!` `-` `+`
- 二元计算符 : `+` `-` `/` `*` `%`
- 二元比较符 : `>` `>=` `<` `<=`  `==` `!=`
- 逻辑操作符 : `||` `&&`
- 括号 : `(` `)`

**数据类型**
- 字符串 `"abc"` `'def'`
- 十进制int `123`
- 十进制float `123.4`
- bool `true`
- 变量 `id`

**表达式词法**
- 表达式以换行结束、不支持多行表达式。形如`a + 7 > 100`
- 支持字面量 (上述数据类型的常量)、变量和运算符(上述运算符)
- 变量：由字母数字下划线构成且必须以字母开头，形如：`_id`、`foo`
- 关键字：系统内置部分关键字 
  - `true`: bool类型常量
  - `false`: bool类型常量

## 语法
支持简单的表达式语法 
- 一元运算: `!true`
- 二元运算: `a + b > c`
- 逻辑运算: `a || b == 100`
- 括号: `(a + b) * c`

运算符的优先级

| 优先级 | 运算符                         |
|-----|-----------------------------|
| 0   | `or`                        |
| 1   | `&&`                        |
| 2   | `!` `-` `+`                 |
| 3   | `>` `>=` `<` `<=` `==` `!=` |
| 4   | `+` `-`                     |
| 5   | `*` `/`                     |

## 项目结构
``` shell
.
├── README.md
├── compiler.go
├── compiler_test.go
├── compiler
│   ├── lexical.go 
│   ├── parser.go   # 语法分析
│   ├── parser_test.go
│   ├── planner.go  # 构建语法树
│   ├── scanner.go  # 词法分析
│   └── scanner_test.go
├── executor
│   ├── ast.go      # 抽象语法树定义
│   ├── operator.go # 语法树执行
│   ├── svg.go      # 可视化打印语法树 - 辅助工具
│   ├── symbol.go   # 符号定义
│   ├── type.go     # 类型定义
│   └── type_checker.go # 类型检查
└── token
    ├── kind.go      # token类型
    ├── kind_test.go
    ├── lexer.go     # 词法定义
    └── token.go     # token定义
```

## 项目运行
**启动DB**
```shell
docker-compose up
```

**运行项目**
```shell
go run ./main.go
```