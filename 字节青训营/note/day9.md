学习内容：「微服务框架 - 不变的基建」
- 微服务架构介绍
- 微服务架构原理及特征
- 核心服务治理功能
- 服务治理实践

[手册-4](https://juejin.cn/post/7194381054797905981)

# 微服务架构介绍

## 系统架构的演进历史

单体架构
- All in one process
- 劣势：debug 困难、模块相互影响、模块分工、开发流程

垂直应用架构
- 按照业务线垂直划分
- 优势：业务独立开发维护
- 劣势：不同业务存在冗余、每个业务还是单体

分布式架构
- 抽出与业务无关的公共模块
- 优势:业务无关的独立服务
- 劣势:服务模块bug可导致全站瘫痪、调用关系复杂、不同服务冗余

SOA架构
- 面向服务
- 优势:服务注册
- 劣势:整个系统设计是中心化的、需要从上至下设计、重构困难

微服务架构
- 彻底的服务化
- 优势:开发效率、业务独立设计、自下而上、故障隔离
- 劣势:治理、运维难度、观测挑战、安全性、分布式系统

**微服务架构概览**

![微服务架构概览](../assets/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88.png)

## 微服务架构核心要素

服务治理（本课程内容）
- 服务注册
- 服务发现
- 负载均衡
- 扩缩容
- 流量治理
- 稳定性治理

可观测性
- 日志采集
- 日志分析
- 监控打点
- 监控大盘
- 异常报警
- 链路追踪

安全
- 身份验证
- 认证授权
- 访问令牌
- 审计
- 传输加密
- 黑产攻击

# 微服务架构原理及特征

## 基本概念

- 服务：一组具有相同逻辑的运行实体
- 实例：一个服务中的每个运行实体
- 集群（cluster）：通常指服务内部的逻辑划分包含多个实例
- 实例与进程的关系：没有必然对应关系，一般一对一或者一对多
- 常见的实例承载形式：进程、VM、k8s pod......
- 有状态/无状态服务：服务的实例是否存储了可持久化的数据（例如磁盘文件）


**服务间通信**
- 对于单体服务，不同模块通信只是简单的函数调用
- 对于微服务，服务间通信意味着网络传输
- 常见的通信协议包括 HTTP、RPC

## 服务注册及服务发现
- 基本问题：服务间调用中，如何指定下游服务实例的地址？

简单方案
- 直接指定 ip:port？
    - 没有任何动态能力（ip会变）
    - 有多个实例下游实例怎么办？
- 使用 DNS？
    - 本地 DNS 存在缓存，导致延迟
    - DNS 没有负载均衡
    - 不支持服务探活检查
    - DNS 不能指定端口

更优方案：

**服务注册发现**
![](../assets/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E5%8F%91%E7%8E%B0.png)

- 新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系
- 旧服务实例下线前，从服务注册中心删除该实例，下线流量
- 新服务实例上线后，在服务注册中心注册该实例，上线流量

## 微服务流量特征
- 统一网关入口
- 外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）

网状调用链路：
![网状调用链路](../assets/%E7%BD%91%E7%8A%B6%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF.png)

# 核心服务治理功能

## 服务发布

- 服务发布：让一个服务升级运行新的代码的过程

服务发布难点
- 服务不可用
- 服务抖动
- 服务回滚

蓝绿部署
- 将服务分成两个部分，分别先后发布
- 简单、稳定
- 但需要两倍资源

灰度发布（金丝雀发布）

![灰度发布](../assets/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83.png)
- 先发布少部分实例，接着逐步增加发布比例
- 不需要增加资源
- 回滚难度大，基础设施要求高

## 流量治理

![流量治理](../assets/%E6%B5%81%E9%87%8F%E6%B2%BB%E7%90%86.png)
- 流量控制：在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制
- 控制维度
    - 地区维度
    - 集群维度
    - 实例维度
    - 请求维度

## 负载均衡

负载均衡 (Load Balance)：负责分配请求在每个下游实例上的分布

常见的 LB 策略
- Round Robin
- Random
- Ring Hash
- Least Request

## 稳定性治理
- 线上服务总是会出问题的，这与程序的正确性无关，如：网络攻击、流量突增、机房断电等

微服务架构中典型的稳定性治理功能：

![](../assets/%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B2%BB%E7%90%86.png)

- 限流：限制服务处理的最大 QPS，拒绝过多请求
- 熔断：中断请求路径，增加冷却时间从而让故障实例尝试恢复
- 过载保护：在负载高的实例中，主动拒绝一部分请求，防止实例被打挂
- 降级：服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求

# 服务治理实践

> 字节服务治理实践

**请求重试的意义**

- 本地函数调用
    - 通常没有重试意义
- 远程函数调用
    - 网络抖动、下游负载高、下游机器宕机......
    - 重试是有意义的，可以避免偶发性的错误，提高 SLA

重试的意义
- 降低错误率
    - 假设单次请求的错误概率为 0.01，那么连续两次错误概率则为 0.0001
- 降低长尾延时
    - 对于偶尔耗时较长的请求，重试请求有机会提前返回
- 容忍暂时性错误
    - 某些时候系统会有暂时性异常(例如网络抖动)，重试可以尽量规避
- 避开下游故障实例
    - 一个服务中可能会有少量实例故障 (例如机器故障)，重试其他实例可以成功

请求重试的难点
- 幂等性
    - POST 请求可以重试吗？
- 重试风暴
    - 随着调用链路的增加，重试次数呈指数级上升
- 超时设置
    - 假设调用时间一共 1s，经过多少时间开始重试？

**重试策略**
- 限制重试比例
    - 设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值
- 防止链路重试
    - 返回特殊的 status code，表示“请求失败，但别重试”
- Hedged Requests
    - 对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应

重试效果验证
- 字节跳动重试组件能够极大限制重试发生的链路放大效应
